# Istio快速上手



## 一、Istio的基本介绍

&emsp;&emsp;`Istio`出身名门，是由google、IBM和LYFT在**2017年推出的。**其**初始目标为：在K8s的基础上，以非侵入的方式给服务提供流量管理、安全加固、服务监控、策略管理**等功能。





## 二、Istio的核心组件及其功能

`Istio`总体可分为两部分：

- **应用面**：核心，用于管理istio的**所有**功能；
- **数据面**[`Sidecar`]：以注入的方式**与业务容器运行在同一`POD`**，劫持业务容器的**流量**，接受控制面的控制，向控制面输出**日志、跟踪和监控数据**。



### 2.1 Pilot

&emsp;&emsp;**身份**：`istio`的主要控制点。

&emsp;&emsp;**职责**：管理流量。（执行是sidecar执行的，它只是管理）

从功能层面上，它有两个主要任务：

- 从k8或者注册中心**获取服务信息**，完成**服务发现**过程；
- 读取`Istio`的各项配置，发给数据面进行实施；

> &emsp;&emsp;`Pilot`的配置会进行转换处理，转化成数据面能够理解的格式，`sidecar`根据`polot`指令，将路由、服务、监听、集群等定义信息转换为本地配置。

![未命名绘图](https://gitee.com/tizo_kingbb/picImg/raw/master/img/20220404101548.jpg)

- 工作流程：
  1. 用户通过`API`在`k8s`上创建`CRD`资源，对`Istio`控制面发出指令。
  2. `Pilot`监听`CRD`中的`config`、`rbac`、`networking`、`authentication`资源监测到变更后，发出指令给对应的`Sidecar`。
  3. `Sidecar`根据指令更新自身配置，修正通信行为。

### 2.2 Mixer

&emsp;&emsp;**身份**：像是一个适配器中心。

&emsp;&emsp;**职责**：预检、汇报

![未命名绘图-第 2 页](https://gitee.com/tizo_kingbb/picImg/raw/master/img/20220404105134.jpg)

> &emsp;&emsp;`Mixer`中包含多个`Adapter`组件，这些组件用来处理预检和报告数据，从而完成`Mixer`的各种功能。

- 工作流程：
  1. 用户将`Mixer`配置发送到`Kubernetes`中;
  2. `Mixer`通过对`kubernetes`资源的监听。获取对配置的变化。
  3. 网格中服务在每次调用之前发出**预检**，查看是否可执行。调用之后发送**报告**信息。向`Mixer`回报在调用过程中产生的监控跟踪数据。



### 2.3 Citadel

&emsp;&emsp;**身份**：`istio`的证书控制点。

&emsp;&emsp;**职责**：证书管理

> &emsp;&emsp;早期被称作`Istio-CA`，负责集群中各个服务在统一的`CA`条件下生成证书。下发给`Sidecar`，服务之间的`TLS`就是通过这些证书完成校验过程的。

### 2.4 Sidecar（Envoy）

&emsp;&emsp;**身份**：`istio`的数据面。

&emsp;&emsp;**职责**：控制面对网格控制的实际执行。

> 几个需要了解的点：
>
> - `Sidecar`是由`Envoy`派生而来，只要是支持`Envoy`的`xDS`协议，理论上可以去选择其他反向代理软件替代`Envoy`。
> - `Istio`通过`Istio-init`初始化容器中的`iptables`执行，完成对pod流量的劫持，从而接管pod中应用程序的通信过程。
> - 在统一`pod`内，网络栈是共享的。
>
> ![Istio-第 3 页](https://gitee.com/tizo_kingbb/picImg/raw/master/img/20220404112641.jpg)



## 三、核心配置对象

&emsp;&emsp;利用`Istio`控制为服务通信，是通过向`k8s`提交`CRD`资源的方式完成的。在安装`Istio`的过程中会进行`CRD`的初始化。`CRD`在注册成功之后，会建立一些**基础对象**，完成`Istio`的初始设置。

**`Istio`把资源分为三组进行管理：**

- `networking.istio.io`
- `config.istio.io`
- `authentication.istio.io`



### 3.1 networking.istio.io

&emsp;&emsp;使用频率最高，负责流量管理的相关配置。

#### 3.1.1 Gateway

&emsp;&emsp;无论是网格内部还是服务互相访问，还是通过`Ingress`进入网格内部的流量。**都要是都要**经过`Gateway`。其描述了**边缘接入设备**，其中包含：开放端口、主机名、及可能存在的`TSL`证书的定义。

按流量入口划分，对应的处理程序：

- `Ingress`：通过`Istio Ingress Gateway Controller`进入；
- **内部**：`mesh`网关，代表网格内部的所有`Sidecar`;

> &emsp;&emsp;`Pilot`会根据`Gateway`和主机名进行检索。如果存在对应的`VirtualService`，则交由`VirtualService`处理。如果没有则尝试寻找`kubernetes Service`,还不存在就抛`404`。



#### 3.1.2 VirtualService

**主要组成部分：**

- `Host`：该对象负责的**主机名称**，on k8s，可能就是个服务名；
- `Gateway`：来源网关，缺省值为：`mesh`，那么也就意味着默认是网格内部互联所用的网关；
- **路由对象**：负责根据实际协议对流量的处理方式进行甄别。
  - `http`：透明协议，可以完成更细致的控制；
  - `tcp`：无法完成过于复杂的任务；



#### 3.1.3 TCP/TLS/HTTP Route

两个主要部分：

- 匹配条件
- 目的路由



**Http Route为例：**

- `HTTPMatchRequest`对象数组：用于匹配
  - 匹配规则：
    - uri
    - header
    - 等
  - 额外特性：
    - 超时控制
    - 重试
    - 错误注入
- `DestinationWeight`对象：描述目标服务



#### 3.1.4 DestinationWeight

&emsp;&emsp;各协议路由的目标，`DestinationWeight`指定到某个（目标`Destination`对象）的流量权重，多个目标可**同时**为该`VirtualService`提供服务。并按照权重进行流量分配。



#### 3.1.5 Destination

**组成**：

- `SubSet`：服务的一个子集，在`k8s`中表示使用标签选择器区分的不同`pod`。
- `Port`：服务的端口。



### 3.2 config.istio.io

&emsp;&emsp;为`Mixer`组件提供配置，该组件存在大量的适配器，变得相对复杂。

**`Mixer`的数据处理流程：**

![Istio-Mixer数据处理流程](https://gitee.com/tizo_kingbb/picImg/raw/master/img/20220404135807.jpg)



#### 3.2.1 Rule

&emsp;&emsp;包含一个`match`成员和一个逻辑表达式，当符合表达式条件时才会交给`Action`处理。**表达式中的变量称为`attribute`属性，其中内容来自`envoy`提交的数据。**

#### 3.2.2 Action

&emsp;&emsp;职责：符合入口标准的数据，在用什么方式加工之后，交给哪个适配器进行处理。

&emsp;&emsp;两个主要成员：

- `Instance`：使用`Template`对接收到的数据进行处理；
- `Handler`：一个适配器的实例，用于接收处理。

#### 3.2.3 Instance

&emsp;&emsp;为进入的数据选择一个模板，抽取某些字段作为模板的参数。

#### 3.2.4 Adapter

&emsp;&emsp;可以理解为行为规范，需要根据这套规范去实例话，之后才能正常使用。例如`RedisQuota`适配器中的`Redis`地址。当数据得到正式的初始化，`Adapter`才能正常被投入使用。

#### 3.2.5 Template

&emsp;&emsp;主要作用就是对收到的**数据进行再加工**。进入`Mixer`中的数据都来自于`Sidecar`。这就导致需要各式各样的适配器，也就导致了即时是同一适配器，都有可能收到不同的数据。这就是`Template`的主要功能。

#### 3.2.6 Handler

&emsp;&emsp;`Handler`对象用于对`Adapter`进行实例化。



### 3.3 authentication.istio.io

&emsp;&emsp;其定义了**认证策略**，其对网格级别、命名空间、命名空间级别及服务级别都提供了认证策略要求（要求内容中包含服务间的通信认证，基于JWT的终端认证）。



#### 3.3.1 Policy

&emsp;&emsp;服务一级的认证策略，如果命名为`default`那么他采用以下认证策略。

- 策略目标：包含服务名、端口号
- 认证方法：
  - `peers`：服务间认证；
  - `origins`：设置终端认证；



#### 3.3.2 MeshPolicy

&emsp;&emsp;只能被命名为`default`，其代表的是网格内部应用的默认认证策略。



### 3.4 rbac.istio.io

&emsp;&emsp;一套基于角色的访问控制系统（`RBAC`）,与`k8s`中的颇为相似。

#### 3.4.1 ServiceRole

&emsp;&emsp;由一系列规则（`rules`）组成，每个规则对应一条权限，其中描述了权限所对应的：服务、服务路径、方法。还有**自定义的约束**。

#### 3.4.2 ServiceRoleBinding

&emsp;&emsp将用户主体（可能是用户或者服务）和`ServiceRole`进行绑定。





## 四、快速部署Istio

[点击查看当前k8s对应版本的Istio]([Istio / Supported Releases](https://istio.io/latest/docs/releases/supported-releases/#support-status-of-istio-releases))

> &emsp;&emsp;我是用的是k8s的1.17.9版本，下载的都是其对应的内容。根据你们所运行的环境自行替换部分内容。

```shell
cd /home
mkdir istio && cd istio
wget https://github.com/istio/istio/releases/download/1.9.6/istio-1.9.6-linux-amd64.tar.gz #替换
tar -zvxf istio-1.9.6-linux-amd64.tar.gz
cd istio-1.9.6
### 将istioctl放到path
cp bin/istioctl /usr/local/bin
### 安装istio
istioctl install --set profile=demo -y

### 输出如下
✔ Istio core installed                                                          
✔ Istiod installed                                                              
✔ Egress gateways installed                                                     
✔ Ingress gateways installed          
✔ Installation complete 

### 查看istio的启动状态
kubectl get pods -n istio-system -w


### 卸载istio
istioctl x uninstall --purge
kubectl delete namespace istio-system
```



## 五、上手各种Istio组件



### 5.1 部署两个版本的应用

#### 5.1.1 部署服务端

1. 创建`yaml`文件

   ```yaml
   apiVersion: v1
   kind: Service
   metadata:
     name: flaskapp
     namespace: study-king # 替换成自己的
     labels:
       app: flaskapp
   spec:
     selector:
       app: flaskapp
     ports:
       - name: http
         port: 80
   ---
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: flaskapp-v1
     namespace: study-king
   spec:
     replicas: 1
     selector:
       matchLabels:
         app: flaskapp
         version: v1
     template:
       metadata:
         labels:
           app: flaskapp
           version: v1
       spec:
         containers:
         - name: flaskapp
           image: dustise/flaskapp
           imagePullPolicy: Always
           env:
           - name: version
             value: v1
   ---
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: flaskapp-v2
     namespace: study-king # 替换成自己的
   spec:
     replicas: 1
     selector:
       matchLabels:
         app: flaskapp
         version: v2
     template:
       metadata:
         labels:
           app: flaskapp
           version: v2
       spec:
         containers:
         - name: flaskapp
           image: dustise/flaskapp
           imagePullPolicy: Always
           env:
           - name: version
             value: v2
   ```

2. 执行命令部署

   ```shell
   ### 注入后部署
   istioctl kube-inject -f flask.istio.yaml | kubectl apply -f -
   
   ### 查看创建出来的pod
   kubectl get po -n study-king -w  # study-king 替换成自己的
   
   ### 查看pod内部容器情况
   kubectl describe po -n study-king flaskapp-v1-77958679d8-2rbvt # flaskapp-v1-77958679d8-2rbvt 替换成自己的
   
   ### 分析pod中的容器情况
   #1、istio-proxy：注入结果；
   #2、istio-init：初始化容器，初始劫持的；
   ```



#### 5.1.2 部署客户端服务

1. 创建`yaml`文件

   ```yaml
   apiVersion: v1
   kind: Service
   metadata:
     name: sleep
     namespace: study-king
     labels:
       app: sleep
       version: v1
   spec:
     selector:
       app: sleep
       version: v1
     ports:
       - name: ssh
         port: 80
   ---
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: sleep
     namespace: study-king
   spec:
     replicas: 1
     selector:
       matchLabels:
         app: sleep
         version: v1
     template:
       metadata:
         labels:
           app: sleep
           version: v1
       spec:
         containers:
         - name: sleep
           image: dustise/sleep
           imagePullPolicy: IfNotPresent
   ---
   ```

2. 根据`yaml`创建服务

   ```shell
   istioctl kube-inject -f sleep.yaml | kubectl apply -f -
   ```

3. 查看服务

   ```shell
   kubectl exec -it sleep-77cd98dc54-vnccf -n study-king -c sleep bash # 注意替换
   ```

4. 验证服务

   ```shell
   for i in `seq 10`;do http --body http://flaskapp/env/version;done
   ```

5. 输出结果

   ```shell
   v1
   v2
   v1
   v2
   v1
   v2
   v1
   v2
   v1
   v2
   ```

6. 创建目标规则和默认路由

   - 目标规则`flaskapp-destinationrule.yaml`

     ```yaml
     ### 把flaskapp分成两个subset
     apiVersion: networking.istio.io/v1alpha3
     kind: DestinationRule
     metadata:
       name: flaskapp
       namespace: study-king # 替换
     spec:
       host: flaskapp
       subsets:
       - name: v1
         labels:
           version: v1
       - name: v2
         labels:
           version: v2
     
     ```

     ```shell
     kubectl apply -f flaskapp-destinationrule.yaml
     ```

   - 默认路由`flaskapp-default-vs-v2.yaml`

     ```yaml
     # 接管 flaskapp 的流量
     apiVersion: networking.istio.io/v1alpha3
     kind: VirtualService
     metadata:
       name: flaskapp-default-v2
       namespace: study-king # 替换
     spec:
       hosts:
       - flaskapp
       http:
       - route:
         - destination:
             host: flaskapp
             subset: v2
     
     ```

     ```shell
     kubectl apply -f flaskapp-default-vs-v2.yaml
     ```

7. 再次访问服务：

   ```shell
   for i in `seq 10`;do http --body http://flaskapp/env/version;done
   
   ……
   
   v2
   v2
   v2
   
   ……
   ```

   

## 六、【真】安装Istio

&emsp;&emsp;`Istio`与`k8s`进行了深度集成，每个`Istio`的组件都以`Deployment`的形式存在。并且在整个运行的过程中也需要依赖各种`CRD`及`ConfigMap`、`Secret`等进行存储。

### 6.1 Istio Chart概述

&emsp;&emsp;其是一个总分结构，分级结构与设计结构一致。

![Istio-Helm Chart](https://gitee.com/tizo_kingbb/picImg/raw/master/img/20220405093919.jpg)







### 6.x 官方安装步骤

```shell
#1、创建命名空间
kubectl create namespace istio-system
# 2、安装 Istio base chart，它包含了 Istio 控制平面用到的集群范围的资源：
cd /home/yiming/istio/istio-1.9.6
helm install istio-base manifests/charts/base -n istio-system
# 3、安装 Istio discovery chart，它用于部署 istiod 服务：
helm install istiod manifests/charts/istio-control/istio-discovery \
    --set global.hub="docker.io/istio" \
    --set global.tag="1.9.6" \
    -n istio-system

# 4、(可选项) 安装 Istio 的入站网关 chart，它包含入站网关组件：
helm install istio-ingress manifests/charts/gateways/istio-ingress \
    --set global.hub="docker.io/istio" \
    --set global.tag="1.9.6" \
    -n istio-system

# 5、(可选项) 安装 Istio 的出站网关 chart，它包含了出站网关组件：
helm install istio-egress manifests/charts/gateways/istio-egress \
    --set global.hub="docker.io/istio" \
    --set global.tag="1.9.6" \
    -n istio-system

# 6、3ighvcgt.mirror.aliyuncs.com 镜像加速


helm install istiod manifests/charts/istio-control/istio-discovery \
    --set global.hub="3ighvcgt.mirror.aliyuncs.com/istio" \
    --set global.tag="1.9.6" \
    -n istio-system

helm install istio-ingress manifests/charts/gateways/istio-ingress \
    --set global.hub="3ighvcgt.mirror.aliyuncs.com/istio" \
    --set global.tag="1.9.6" \
    -n istio-system

helm install istio-egress manifests/charts/gateways/istio-egress \
    --set global.hub="3ighvcgt.mirror.aliyuncs.com/istio" \
    --set global.tag="1.9.6" \
    -n istio-system
```



### 6.X 官方不推荐helm后

```shell
### 在istio目录下
istioctl install --manifests=manifests/
```





# Istio的常用功能

&emsp;&emsp;这一部分描述了`Istio`在各种场景下的应用。包括：流量控制、开箱即用的可视化。涉及`Grafana`、`prometheus`、`jaeger`、`Kiali`。



## 一、Sidecar的注入

&emsp;&emsp;有上所述，可以猜测出`istioctl`在`yaml`上做了手脚，给包上了代理。那么它究竟都动了些什么内容呢。

```shell
# 将注入内容后的yml输出到文件
istioctl kube-inject -f flask.istio.yaml -o flask.istio.injected.yaml
```

**多处的重要内容：**

- `Sidecar`容器：数据面。上边已经进行了描述
- `istio-init（initContainers）`：就是上边说的初始化容器，用来劫持应用通讯的。



### 1.1 手动注入

&emsp;&emsp;上边已经使用过了，这里补充一些内容。因为默认情况下`istioctl`与`k8s`中的`istio`服务沟通之后才能完成注入。这里介绍一种使用本地配置注入的方式：

1. 配置本地副本

   ```shell
   kubectl -n istio-system get configmap istio-sidecar-injector -o=jsonpath='{.data.config}' > inject-config.yaml
   kubectl -n istio-system get configmap istio-sidecar-injector -o=jsonpath='{.data.values}' > inject-values.yaml
   kubectl -n istio-system get configmap istio -o=jsonpath='{.data.mesh}' > mesh-config.yaml
   ```

2. 制定本地配置注入

   ```shell
   istioctl kube-inject \
       --injectConfigFile inject-config.yaml \
       --meshConfigFile mesh-config.yaml \
       --valuesFile inject-values.yaml \
       --filename flask.istio.yaml \
       | kubectl apply -f -
   ```



### 1.2 自动注入

&emsp;&emsp;`Istio`提供了的[准入控制器变更 Webhook](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/)，可以将 `Sidecar` 自动添加到可用的 `Kubernetes Pod` 中。准入控制器默认情况下是启动的，但一些 `Kubernetes` 发行版会禁用他们。如果出现这种情况，根据说明来[启用准入控制器](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#how-do-i-turn-on-an-admission-controller)。

**启动自动注入：**

- 命名空间：`kubectl label namespace auto istio-injection=enabled --overwrite`

**禁用自动注入：**

- 命名空间：`kubectl label namespace auto istio-injection-`

> 注意：
>
> - 需要`Injection webhook`被启用。
>
> - 区别于手动注入，**自动注入发生在`Pod`层面**。将看不到`Deployment`本身有任何更改。需要检查单独的`Pod`
>
>   ```shell
>   kubectl -n auto describe pod sleep-7575b5d557-44bfp
>   ```



**注入启用规则表：**

| 命名空间是否符合条件 | autoInject | sidecar.istio.io/inject | 是否注入 |
| :------------------: | :--------: | :---------------------: | :------: |
|          是          |  enabled   |          true           |    是    |
|          是          |  enabled   |          false          |    否    |
|          是          |  enabled   |         未注解          |    是    |
|          是          |  disabled  |          true           |    是    |
|          是          |  disabled  |          false          |    否    |
|          是          |  disabled  |         未注解          |    否    |
|          否          |  enabled   |          true           |    否    |
|          否          |  enabled   |          false          |    否    |
|          否          |  enabled   |         未注解          |    否    |
|          否          |  disabled  |          true           |    否    |
|          否          |  disabled  |          false          |    否    |
|          否          |  disabled  |         未注解          |    否    |



**自动注入配置：**

- 其依赖`Mustating Admission Webhook`

- 查看istio-sidecar-injector：`kubectl get mutatingwebhookconfiguration istio-sidecar-injector -o yaml`

  - 默认：`istio-injection:enabled`在webhooks的namespaceSelector下；
  - 当 apiserver 接收到与规则相匹配的请求时，会根据`clientconfig`配置中的`name: istio-sidecar-injector`向 webhook 服务发送审查请求。

- 查看默认的注入策略：

  - `kubectl -n istio-system get configmap istio-sidecar-injector -o=jsonpath='{.data.config}'`；
  - 及查看 `istio-sidecar-injector` 的ConfigMap；
  - 两个`configmap`的常用配置：
    - `neverInjectSelector`：或关系，符合规则的pod不进行注入
    - `alwaysInjectSelector`：或关系，符合规则的pod都会注入

- 在pod模版中声明不使用自动注入：

  ```shell
  apiVersion: extensions/v1beta1
  kind: Deployment
  metadata:
    name: ignored
  spec:
    template:
      metadata:
        annotations:
          sidecar.istio.io/inject: "false" # 声明为false
      spec:
        containers:
        - name: ignored
          image: tutum/curl
          command: ["/bin/sleep","infinity"]
  ```



#### 1.2.1 自动注入优先级

- pod上的注解
- `neverInjectSelector`
- `alwaysInjectSelector`
- 命名空间策略

##### 1.2.1.1 排查没有设置自动注入的pod被自动注入的问题

```shell
### 1、查看的日志
pod=$(kubectl -n istio-system get pods -l istio=sidecar-injector -o jsonpath='{.items[0].metadata.name}')
kubectl -n istio-system logs -f $pod

### 2、更改其日志打印级别,每个istio的组件都有这个配置
'--log_output_level=default:info'

### 3、如果还判断不出的话根据上述顺序排查
```

#### 1.2.2 常用命令总结

##### 1.2.2.1 查看当前namespace的label

```shell
kubectl get namespaces --show-labels
```



### 1.3 注入对工作负载的要求

&emsp;&emsp;目前支持的工作负载类型包括但不限于：`Job`、`DaemonSer`、`ReplicaSet`、`Pod`、`Deployment`。

**要求：**

- 正确命名服务端口：

  - 必需使用协议名为前缀：`http`、`http2`、`mongo`、`redis`、`grpc`。
  - 其他的：全部当作`TCP`处理。

  >目前版本对`HTTP`协议相关内容有最大范围的支持。包括`gRpc`和`HTTP2`。

- 工作负载的`POD`必需关联`Service`
  - 即使你没有开放任何端口，也需要注册一个service对象。
- 还建议：
  - pod模版中加入两个标签：`app`和`version`,istio很多默认策略需要引用。





## 二、grafana&Prometheus&Jarger&Kiali

### 2.1 组件的安装

```shell
### 进入istio的目录
cd /home/yiming/istio/istio-1.13.2
### 安装
kubectl apply -f samples/addons
```



### 2.2 测试应用准备

```shell
### 1、default空间开启自动注入
kubectl label ns default istio-injection=enabled
### 2、部署sleep
kubectl apply -f sleep.istio.yaml
### 3、部署flask
kubectl apply -f flask.istio.yaml
### 4、查看pods
kubectl get po
```



### 2.3 Grafana

此示例提供以下仪表板：

- [网格仪表板](https://grafana.com/grafana/dashboards/7639)提供网格中所有服务的概述。
- [服务仪表板](https://grafana.com/grafana/dashboards/7636)提供服务指标的详细细分。
- [工作负载仪表板](https://grafana.com/grafana/dashboards/7630)提供工作负载指标的详细细分。
- [性能仪表板](https://grafana.com/grafana/dashboards/11829)监视网格的资源使用情况。
- [控制平面仪表板](https://grafana.com/grafana/dashboards/7645)监视控制平面的运行状况和性能。
- [WASM 扩展仪表板](https://grafana.com/grafana/dashboards/13277)提供了网格宽 WebAssembly 扩展运行时和加载状态的概述。



1. 开放grafana端口或者是网关抛出去

   ```shell
   ### 此处是开放端口
   kubectl -n istio-system port-forward \
   $(kubectl -n istio-system get pod -l app=grafana -o jsonpath='{.items[0].metadata.name}') \
   3000:3000 &
   ```

2. 访问后进入：`Istio Mesh Dashboard`

3. 进入`sleep`后执行

   ```shell
   ###1、进入sleep
   kubectl exec -it -c sleep sleep-v1-7fd9d48754-kk5jd bash
   ###2、执行命令
   for i in `seq 100`;do http --body http://flaskapp/fetch?url=http://flaskapp/env/version >> /dev/null ; done
   ```



### 2.4 Prometheus

&emsp;&emsp;云原生阵营中监控系统的实施标准。`Grafana`知识一个可视化的前端，其数据都是来自我们的`prometheus`。下载展示一些简易的查询操作。

1. 将Prometheus抛出

   ```shell
   kubectl -n istio-system port-forward \
   $(kubectl -n istio-system get pod -l app=prometheus -o jsonpath='{.items[0].metadata.name}') \
   9090:9090 &
   ```

2. 打开prometheus的查询页面,输入`istio_requests_total`

   ![image-20220407211502097](https://gitee.com/tizo_kingbb/picImg/raw/master/img/20220407211507.png)



### 2.5 Jaeger

&emsp;&emsp;分布式链路跟踪的开源软件，提供了原生的`OPenTracing`支持，向下兼容`ZipKin`。



1. 抛出jaeger

   ```shell
   kubectl -n istio-system port-forward \
   $(kubectl -n istio-system get pod -l app=jaeger -o jsonpath='{.items[0].metadata.name}') \ 
   16686:16686 &
   ```

2. 进入`localhost:16686`查看服务链路



> **注意：**使用`jaeger`需要服务开启请求头转发。
>
> 需要转发的列表：
>
> - x-request-id
> - x-b3-traceid
> - x-b3-spanid
> - x-b3-parentspanid
> - x-b3-sampled
> - x-b3-flags
> - X-ot-span-context



### 2.6 Kiali

&emsp;&emsp;其是专用于`istio`的，它除了提供监控、可视化及跟踪等功能之外。还专门提供了**Istio的配置验证、健康评估等。**

**抛出：**

```shell
kubectl -n istio-system port-forward \
$(kubectl -n istio-system get pod -l app=kiali -o jsonpath='{.items[0].metadata.name}') \ 
20001:20001 &
```

