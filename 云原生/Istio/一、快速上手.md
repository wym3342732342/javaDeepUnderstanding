

# Istio快速上手



## 一、Istio的基本介绍

&emsp;&emsp;`Istio`出身名门，是由google、IBM和LYFT在**2017年推出的。**其**初始目标为：在K8s的基础上，以非侵入的方式给服务提供流量管理、安全加固、服务监控、策略管理**等功能。





## 二、Istio的核心组件及其功能

`Istio`总体可分为两部分：

- **应用面**：核心，用于管理istio的**所有**功能；
- **数据面**[`Sidecar`]：以注入的方式**与业务容器运行在同一`POD`**，劫持业务容器的**流量**，接受控制面的控制，向控制面输出**日志、跟踪和监控数据**。



### 2.1 Pilot

&emsp;&emsp;**身份**：`istio`的主要控制点。

&emsp;&emsp;**职责**：管理流量。（执行是sidecar执行的，它只是管理）

从功能层面上，它有两个主要任务：

- 从k8或者注册中心**获取服务信息**，完成**服务发现**过程；
- 读取`Istio`的各项配置，发给数据面进行实施；

> &emsp;&emsp;`Pilot`的配置会进行转换处理，转化成数据面能够理解的格式，`sidecar`根据`polot`指令，将路由、服务、监听、集群等定义信息转换为本地配置。

![未命名绘图](https://gitee.com/tizo_kingbb/picImg/raw/master/img/20220404101548.jpg)

- 工作流程：
  1. 用户通过`API`在`k8s`上创建`CRD`资源，对`Istio`控制面发出指令。
  2. `Pilot`监听`CRD`中的`config`、`rbac`、`networking`、`authentication`资源监测到变更后，发出指令给对应的`Sidecar`。
  3. `Sidecar`根据指令更新自身配置，修正通信行为。

### 2.2 Mixer

&emsp;&emsp;**身份**：像是一个适配器中心。

&emsp;&emsp;**职责**：预检、汇报

![未命名绘图-第 2 页](https://gitee.com/tizo_kingbb/picImg/raw/master/img/20220404105134.jpg)

> &emsp;&emsp;`Mixer`中包含多个`Adapter`组件，这些组件用来处理预检和报告数据，从而完成`Mixer`的各种功能。

- 工作流程：
  1. 用户将`Mixer`配置发送到`Kubernetes`中;
  2. `Mixer`通过对`kubernetes`资源的监听。获取对配置的变化。
  3. 网格中服务在每次调用之前发出**预检**，查看是否可执行。调用之后发送**报告**信息。向`Mixer`回报在调用过程中产生的监控跟踪数据。



### 2.3 Citadel

&emsp;&emsp;**身份**：`istio`的证书控制点。

&emsp;&emsp;**职责**：证书管理

> &emsp;&emsp;早期被称作`Istio-CA`，负责集群中各个服务在统一的`CA`条件下生成证书。下发给`Sidecar`，服务之间的`TLS`就是通过这些证书完成校验过程的。

### 2.4 Sidecar（Envoy）

&emsp;&emsp;**身份**：`istio`的数据面。

&emsp;&emsp;**职责**：控制面对网格控制的实际执行。

> 几个需要了解的点：
>
> - `Sidecar`是由`Envoy`派生而来，只要是支持`Envoy`的`xDS`协议，理论上可以去选择其他反向代理软件替代`Envoy`。
> - `Istio`通过`Istio-init`初始化容器中的`iptables`执行，完成对pod流量的劫持，从而接管pod中应用程序的通信过程。
> - 在统一`pod`内，网络栈是共享的。
>
> ![Istio-第 3 页](https://gitee.com/tizo_kingbb/picImg/raw/master/img/20220404112641.jpg)



## 三、核心配置对象

&emsp;&emsp;利用`Istio`控制为服务通信，是通过向`k8s`提交`CRD`资源的方式完成的。在安装`Istio`的过程中会进行`CRD`的初始化。`CRD`在注册成功之后，会建立一些**基础对象**，完成`Istio`的初始设置。

**`Istio`把资源分为三组进行管理：**

- `networking.istio.io`
- `config.istio.io`
- `authentication.istio.io`



### 3.1 networking.istio.io

&emsp;&emsp;使用频率最高，负责流量管理的相关配置。

#### 3.1.1 Gateway

&emsp;&emsp;无论是网格内部还是服务互相访问，还是通过`Ingress`进入网格内部的流量。**都要是都要**经过`Gateway`。其描述了**边缘接入设备**，其中包含：开放端口、主机名、及可能存在的`TSL`证书的定义。

按流量入口划分，对应的处理程序：

- `Ingress`：通过`Istio Ingress Gateway Controller`进入；
- **内部**：`mesh`网关，代表网格内部的所有`Sidecar`;

> &emsp;&emsp;`Pilot`会根据`Gateway`和主机名进行检索。如果存在对应的`VirtualService`，则交由`VirtualService`处理。如果没有则尝试寻找`kubernetes Service`,还不存在就抛`404`。



#### 3.1.2 VirtualService

**主要组成部分：**

- `Host`：该对象负责的**主机名称**，on k8s，可能就是个服务名；
- `Gateway`：来源网关，缺省值为：`mesh`，那么也就意味着默认是网格内部互联所用的网关；
- **路由对象**：负责根据实际协议对流量的处理方式进行甄别。
  - `http`：透明协议，可以完成更细致的控制；
  - `tcp`：无法完成过于复杂的任务；



#### 3.1.3 TCP/TLS/HTTP Route

两个主要部分：

- 匹配条件
- 目的路由



**Http Route为例：**

- `HTTPMatchRequest`对象数组：用于匹配
  - 匹配规则：
    - uri
    - header
    - 等
  - 额外特性：
    - 超时控制
    - 重试
    - 错误注入
- `DestinationWeight`对象：描述目标服务



#### 3.1.4 DestinationWeight

&emsp;&emsp;各协议路由的目标，`DestinationWeight`指定到某个（目标`Destination`对象）的流量权重，多个目标可**同时**为该`VirtualService`提供服务。并按照权重进行流量分配。



#### 3.1.5 Destination

**组成**：

- `SubSet`：服务的一个子集，在`k8s`中表示使用标签选择器区分的不同`pod`。
- `Port`：服务的端口。



### 3.2 config.istio.io

&emsp;&emsp;为`Mixer`组件提供配置，该组件存在大量的适配器，变得相对复杂。

**`Mixer`的数据处理流程：**

![Istio-Mixer数据处理流程](https://gitee.com/tizo_kingbb/picImg/raw/master/img/20220404135807.jpg)



#### 3.2.1 Rule

&emsp;&emsp;包含一个`match`成员和一个逻辑表达式，当符合表达式条件时才会交给`Action`处理。**表达式中的变量称为`attribute`属性，其中内容来自`envoy`提交的数据。**

#### 3.2.2 Action

&emsp;&emsp;职责：符合入口标准的数据，在用什么方式加工之后，交给哪个适配器进行处理。

&emsp;&emsp;两个主要成员：

- `Instance`：使用`Template`对接收到的数据进行处理；
- `Handler`：一个适配器的实例，用于接收处理。

#### 3.2.3 Instance

&emsp;&emsp;为进入的数据选择一个模板，抽取某些字段作为模板的参数。

#### 3.2.4 Adapter

&emsp;&emsp;可以理解为行为规范，需要根据这套规范去实例话，之后才能正常使用。例如`RedisQuota`适配器中的`Redis`地址。当数据得到正式的初始化，`Adapter`才能正常被投入使用。

#### 3.2.5 Template

&emsp;&emsp;主要作用就是对收到的**数据进行再加工**。进入`Mixer`中的数据都来自于`Sidecar`。这就导致需要各式各样的适配器，也就导致了即时是同一适配器，都有可能收到不同的数据。这就是`Template`的主要功能。

#### 3.2.6 Handler

&emsp;&emsp;`Handler`对象用于对`Adapter`进行实例化。



### 3.3 authentication.istio.io

&emsp;&emsp;其定义了**认证策略**，其对网格级别、命名空间、命名空间级别及服务级别都提供了认证策略要求（要求内容中包含服务间的通信认证，基于JWT的终端认证）。



#### 3.3.1 Policy

&emsp;&emsp;服务一级的认证策略，如果命名为`default`那么他采用以下认证策略。

- 策略目标：包含服务名、端口号
- 认证方法：
  - `peers`：服务间认证；
  - `origins`：设置终端认证；



#### 3.3.2 MeshPolicy

&emsp;&emsp;只能被命名为`default`，其代表的是网格内部应用的默认认证策略。



### 3.4 rbac.istio.io

&emsp;&emsp;一套基于角色的访问控制系统（`RBAC`）,与`k8s`中的颇为相似。

#### 3.4.1 ServiceRole

&emsp;&emsp;由一系列规则（`rules`）组成，每个规则对应一条权限，其中描述了权限所对应的：服务、服务路径、方法。还有**自定义的约束**。

#### 3.4.2 ServiceRoleBinding

&emsp;&emsp将用户主体（可能是用户或者服务）和`ServiceRole`进行绑定。





## 四、快速部署Istio

[点击查看当前k8s对应版本的Istio]([Istio / Supported Releases](https://istio.io/latest/docs/releases/supported-releases/#support-status-of-istio-releases))

> &emsp;&emsp;我是用的是k8s的1.17.9版本，下载的都是其对应的内容。根据你们所运行的环境自行替换部分内容。

```shell
cd /home
mkdir istio && cd istio
wget https://github.com/istio/istio/releases/download/1.9.6/istio-1.9.6-linux-amd64.tar.gz #替换
tar -zvxf istio-1.9.6-linux-amd64.tar.gz
cd istio-1.9.6
### 将istioctl放到path
cp bin/istioctl /usr/local/bin
### 安装istio
istioctl install --set profile=demo -y

### 输出如下
✔ Istio core installed                                                          
✔ Istiod installed                                                              
✔ Egress gateways installed                                                     
✔ Ingress gateways installed          
✔ Installation complete 

### 查看istio的启动状态
kubectl get pods -n istio-system -w


### 卸载istio
istioctl x uninstall --purge
kubectl delete namespace istio-system
```



## 五、上手各种Istio组件



### 5.1 部署两个版本的应用

#### 5.1.1 部署服务端

1. 创建`yaml`文件

   ```yaml
   apiVersion: v1
   kind: Service
   metadata:
     name: flaskapp
     namespace: study-king # 替换成自己的
     labels:
       app: flaskapp
   spec:
     selector:
       app: flaskapp
     ports:
       - name: http
         port: 80
   ---
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: flaskapp-v1
     namespace: study-king
   spec:
     replicas: 1
     selector:
       matchLabels:
         app: flaskapp
         version: v1
     template:
       metadata:
         labels:
           app: flaskapp
           version: v1
       spec:
         containers:
         - name: flaskapp
           image: dustise/flaskapp
           imagePullPolicy: Always
           env:
           - name: version
             value: v1
   ---
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: flaskapp-v2
     namespace: study-king # 替换成自己的
   spec:
     replicas: 1
     selector:
       matchLabels:
         app: flaskapp
         version: v2
     template:
       metadata:
         labels:
           app: flaskapp
           version: v2
       spec:
         containers:
         - name: flaskapp
           image: dustise/flaskapp
           imagePullPolicy: Always
           env:
           - name: version
             value: v2
   ```

2. 执行命令部署

   ```shell
   ### 注入后部署
   istioctl kube-inject -f flask.istio.yaml | kubectl apply -f -
   
   ### 查看创建出来的pod
   kubectl get po -n study-king -w  # study-king 替换成自己的
   
   ### 查看pod内部容器情况
   kubectl describe po -n study-king flaskapp-v1-77958679d8-2rbvt # flaskapp-v1-77958679d8-2rbvt 替换成自己的
   
   ### 分析pod中的容器情况
   #1、istio-proxy：注入结果；
   #2、istio-init：初始化容器，初始劫持的；
   ```



#### 5.1.2 部署客户端服务

1. 创建`yaml`文件

   ```yaml
   apiVersion: v1
   kind: Service
   metadata:
     name: sleep
     namespace: study-king
     labels:
       app: sleep
       version: v1
   spec:
     selector:
       app: sleep
       version: v1
     ports:
       - name: ssh
         port: 80
   ---
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: sleep
     namespace: study-king
   spec:
     replicas: 1
     selector:
       matchLabels:
         app: sleep
         version: v1
     template:
       metadata:
         labels:
           app: sleep
           version: v1
       spec:
         containers:
         - name: sleep
           image: dustise/sleep
           imagePullPolicy: IfNotPresent
   ---
   ```

2. 根据`yaml`创建服务

   ```shell
   istioctl kube-inject -f sleep.yaml | kubectl apply -f -
   ```

3. 查看服务

   ```shell
   kubectl exec -it sleep-77cd98dc54-vnccf -n study-king -c sleep bash # 注意替换
   ```

4. 验证服务

   ```shell
   for i in `seq 10`;do http --body http://flaskapp/env/version;done
   ```

5. 输出结果

   ```shell
   v1
   v2
   v1
   v2
   v1
   v2
   v1
   v2
   v1
   v2
   ```

6. 创建目标规则和默认路由

   - 目标规则`flaskapp-destinationrule.yaml`

     ```yaml
     ### 把flaskapp分成两个subset
     apiVersion: networking.istio.io/v1alpha3
     kind: DestinationRule
     metadata:
       name: flaskapp
       namespace: study-king # 替换
     spec:
       host: flaskapp
       subsets:
       - name: v1
         labels:
           version: v1
       - name: v2
         labels:
           version: v2
     
     ```

     ```shell
     kubectl apply -f flaskapp-destinationrule.yaml
     ```

   - 默认路由`flaskapp-default-vs-v2.yaml`

     ```yaml
     # 接管 flaskapp 的流量
     apiVersion: networking.istio.io/v1alpha3
     kind: VirtualService
     metadata:
       name: flaskapp-default-v2
       namespace: study-king # 替换
     spec:
       hosts:
       - flaskapp
       http:
       - route:
         - destination:
             host: flaskapp
             subset: v2
     
     ```

     ```shell
     kubectl apply -f flaskapp-default-vs-v2.yaml
     ```

7. 再次访问服务：

   ```shell
   for i in `seq 10`;do http --body http://flaskapp/env/version;done
   
   ……
   
   v2
   v2
   v2
   
   ……
   ```

   

## 六、【真】安装Istio

&emsp;&emsp;`Istio`与`k8s`进行了深度集成，每个`Istio`的组件都以`Deployment`的形式存在。并且在整个运行的过程中也需要依赖各种`CRD`及`ConfigMap`、`Secret`等进行存储。

### 6.1 Istio Chart概述

&emsp;&emsp;其是一个总分结构，分级结构与设计结构一致。

![Istio-Helm Chart](https://gitee.com/tizo_kingbb/picImg/raw/master/img/20220405093919.jpg)







### 6.x 官方安装步骤

```shell
#1、创建命名空间
kubectl create namespace istio-system
# 2、安装 Istio base chart，它包含了 Istio 控制平面用到的集群范围的资源：
cd /home/yiming/istio/istio-1.9.6
helm install istio-base manifests/charts/base -n istio-system
# 3、安装 Istio discovery chart，它用于部署 istiod 服务：
helm install istiod manifests/charts/istio-control/istio-discovery \
    --set global.hub="docker.io/istio" \
    --set global.tag="1.9.6" \
    -n istio-system

# 4、(可选项) 安装 Istio 的入站网关 chart，它包含入站网关组件：
helm install istio-ingress manifests/charts/gateways/istio-ingress \
    --set global.hub="docker.io/istio" \
    --set global.tag="1.9.6" \
    -n istio-system

# 5、(可选项) 安装 Istio 的出站网关 chart，它包含了出站网关组件：
helm install istio-egress manifests/charts/gateways/istio-egress \
    --set global.hub="docker.io/istio" \
    --set global.tag="1.9.6" \
    -n istio-system

# 6、3ighvcgt.mirror.aliyuncs.com 镜像加速


helm install istiod manifests/charts/istio-control/istio-discovery \
    --set global.hub="3ighvcgt.mirror.aliyuncs.com/istio" \
    --set global.tag="1.9.6" \
    -n istio-system

helm install istio-ingress manifests/charts/gateways/istio-ingress \
    --set global.hub="3ighvcgt.mirror.aliyuncs.com/istio" \
    --set global.tag="1.9.6" \
    -n istio-system

helm install istio-egress manifests/charts/gateways/istio-egress \
    --set global.hub="3ighvcgt.mirror.aliyuncs.com/istio" \
    --set global.tag="1.9.6" \
    -n istio-system
```



### 6.X 官方不推荐helm后

```shell
### 在istio目录下
istioctl install --manifests=manifests/
```





# Istio的常用功能

&emsp;&emsp;这一部分描述了`Istio`在各种场景下的应用。包括：流量控制、开箱即用的可视化。涉及`Grafana`、`prometheus`、`jaeger`、`Kiali`。



## 一、Sidecar的注入

&emsp;&emsp;有上所述，可以猜测出`istioctl`在`yaml`上做了手脚，给包上了代理。那么它究竟都动了些什么内容呢。

```shell
# 将注入内容后的yml输出到文件
istioctl kube-inject -f flask.istio.yaml -o flask.istio.injected.yaml
```

**多处的重要内容：**

- `Sidecar`容器：数据面。上边已经进行了描述
- `istio-init（initContainers）`：就是上边说的初始化容器，用来劫持应用通讯的。



### 1.1 手动注入

&emsp;&emsp;上边已经使用过了，这里补充一些内容。因为默认情况下`istioctl`与`k8s`中的`istio`服务沟通之后才能完成注入。这里介绍一种使用本地配置注入的方式：

1. 配置本地副本

   ```shell
   kubectl -n istio-system get configmap istio-sidecar-injector -o=jsonpath='{.data.config}' > inject-config.yaml
   kubectl -n istio-system get configmap istio-sidecar-injector -o=jsonpath='{.data.values}' > inject-values.yaml
   kubectl -n istio-system get configmap istio -o=jsonpath='{.data.mesh}' > mesh-config.yaml
   ```

2. 制定本地配置注入

   ```shell
   istioctl kube-inject \
       --injectConfigFile inject-config.yaml \
       --meshConfigFile mesh-config.yaml \
       --valuesFile inject-values.yaml \
       --filename flask.istio.yaml \
       | kubectl apply -f -
   ```



### 1.2 自动注入

&emsp;&emsp;`Istio`提供了的[准入控制器变更 Webhook](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/)，可以将 `Sidecar` 自动添加到可用的 `Kubernetes Pod` 中。准入控制器默认情况下是启动的，但一些 `Kubernetes` 发行版会禁用他们。如果出现这种情况，根据说明来[启用准入控制器](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#how-do-i-turn-on-an-admission-controller)。

**启动自动注入：**

- 命名空间：`kubectl label namespace auto istio-injection=enabled --overwrite`

**禁用自动注入：**

- 命名空间：`kubectl label namespace auto istio-injection-`

> 注意：
>
> - 需要`Injection webhook`被启用。
>
> - 区别于手动注入，**自动注入发生在`Pod`层面**。将看不到`Deployment`本身有任何更改。需要检查单独的`Pod`
>
>   ```shell
>   kubectl -n auto describe pod sleep-7575b5d557-44bfp
>   ```



**注入启用规则表：**

| 命名空间是否符合条件 | autoInject | sidecar.istio.io/inject | 是否注入 |
| :------------------: | :--------: | :---------------------: | :------: |
|          是          |  enabled   |          true           |    是    |
|          是          |  enabled   |          false          |    否    |
|          是          |  enabled   |         未注解          |    是    |
|          是          |  disabled  |          true           |    是    |
|          是          |  disabled  |          false          |    否    |
|          是          |  disabled  |         未注解          |    否    |
|          否          |  enabled   |          true           |    否    |
|          否          |  enabled   |          false          |    否    |
|          否          |  enabled   |         未注解          |    否    |
|          否          |  disabled  |          true           |    否    |
|          否          |  disabled  |          false          |    否    |
|          否          |  disabled  |         未注解          |    否    |



**自动注入配置：**

- 其依赖`Mustating Admission Webhook`

- 查看istio-sidecar-injector：`kubectl get mutatingwebhookconfiguration istio-sidecar-injector -o yaml`

  - 默认：`istio-injection:enabled`在webhooks的namespaceSelector下；
  - 当 apiserver 接收到与规则相匹配的请求时，会根据`clientconfig`配置中的`name: istio-sidecar-injector`向 webhook 服务发送审查请求。

- 查看默认的注入策略：

  - `kubectl -n istio-system get configmap istio-sidecar-injector -o=jsonpath='{.data.config}'`；
  - 及查看 `istio-sidecar-injector` 的ConfigMap；
  - 两个`configmap`的常用配置：
    - `neverInjectSelector`：或关系，符合规则的pod不进行注入
    - `alwaysInjectSelector`：或关系，符合规则的pod都会注入

- 在pod模版中声明不使用自动注入：

  ```shell
  apiVersion: extensions/v1beta1
  kind: Deployment
  metadata:
    name: ignored
  spec:
    template:
      metadata:
        annotations:
          sidecar.istio.io/inject: "false" # 声明为false
      spec:
        containers:
        - name: ignored
          image: tutum/curl
          command: ["/bin/sleep","infinity"]
  ```



#### 1.2.1 自动注入优先级

- pod上的注解
- `neverInjectSelector`
- `alwaysInjectSelector`
- 命名空间策略

##### 1.2.1.1 排查没有设置自动注入的pod被自动注入的问题

```shell
### 1、查看的日志
pod=$(kubectl -n istio-system get pods -l istio=sidecar-injector -o jsonpath='{.items[0].metadata.name}')
kubectl -n istio-system logs -f $pod

### 2、更改其日志打印级别,每个istio的组件都有这个配置
'--log_output_level=default:info'

### 3、如果还判断不出的话根据上述顺序排查
```

#### 1.2.2 常用命令总结

##### 1.2.2.1 查看当前namespace的label

```shell
kubectl get namespaces --show-labels
```



### 1.3 注入对工作负载的要求

&emsp;&emsp;目前支持的工作负载类型包括但不限于：`Job`、`DaemonSer`、`ReplicaSet`、`Pod`、`Deployment`。

**要求：**

- 正确命名服务端口：

  - 必需使用协议名为前缀：`http`、`http2`、`mongo`、`redis`、`grpc`。
  - 其他的：全部当作`TCP`处理。

  >目前版本对`HTTP`协议相关内容有最大范围的支持。包括`gRpc`和`HTTP2`。

- 工作负载的`POD`必需关联`Service`
  - 即使你没有开放任何端口，也需要注册一个service对象。
- 还建议：
  - pod模版中加入两个标签：`app`和`version`,istio很多默认策略需要引用。





## 二、grafana&Prometheus&Jarger&Kiali

### 2.1 组件的安装

```shell
### 进入istio的目录
cd /home/yiming/istio/istio-1.13.2
### 安装
kubectl apply -f samples/addons
```



### 2.2 测试应用准备

```shell
### 1、default空间开启自动注入
kubectl label ns default istio-injection=enabled
### 2、部署sleep
kubectl apply -f sleep.istio.yaml
### 3、部署flask
kubectl apply -f flask.istio.yaml
### 4、查看pods
kubectl get po
```



### 2.3 Grafana

此示例提供以下仪表板：

- [网格仪表板](https://grafana.com/grafana/dashboards/7639)提供网格中所有服务的概述。
- [服务仪表板](https://grafana.com/grafana/dashboards/7636)提供服务指标的详细细分。
- [工作负载仪表板](https://grafana.com/grafana/dashboards/7630)提供工作负载指标的详细细分。
- [性能仪表板](https://grafana.com/grafana/dashboards/11829)监视网格的资源使用情况。
- [控制平面仪表板](https://grafana.com/grafana/dashboards/7645)监视控制平面的运行状况和性能。
- [WASM 扩展仪表板](https://grafana.com/grafana/dashboards/13277)提供了网格宽 WebAssembly 扩展运行时和加载状态的概述。



1. 开放grafana端口或者是网关抛出去

   ```shell
   ### 此处是开放端口
   kubectl -n istio-system port-forward \
   $(kubectl -n istio-system get pod -l app=grafana -o jsonpath='{.items[0].metadata.name}') \
   3000:3000 &
   ```

2. 访问后进入：`Istio Mesh Dashboard`

3. 进入`sleep`后执行

   ```shell
   ###1、进入sleep
   kubectl exec -it -c sleep sleep-v1-7fd9d48754-kk5jd bash
   ###2、执行命令
   for i in `seq 100`;do http --body http://flaskapp/fetch?url=http://flaskapp/env/version >> /dev/null ; done
   ```



### 2.4 Prometheus

&emsp;&emsp;云原生阵营中监控系统的实施标准。`Grafana`知识一个可视化的前端，其数据都是来自我们的`prometheus`。下载展示一些简易的查询操作。

1. 将Prometheus抛出

   ```shell
   kubectl -n istio-system port-forward \
   $(kubectl -n istio-system get pod -l app=prometheus -o jsonpath='{.items[0].metadata.name}') \
   9090:9090 &
   ```

2. 打开prometheus的查询页面,输入`istio_requests_total`

   ![image-20220407211502097](https://gitee.com/tizo_kingbb/picImg/raw/master/img/20220407211507.png)



### 2.5 Jaeger

&emsp;&emsp;分布式链路跟踪的开源软件，提供了原生的`OPenTracing`支持，向下兼容`ZipKin`。



1. 抛出jaeger

   ```shell
   kubectl -n istio-system port-forward \
   $(kubectl -n istio-system get pod -l app=jaeger -o jsonpath='{.items[0].metadata.name}') \ 
   16686:16686 &
   ```

2. 进入`localhost:16686`查看服务链路



> **注意：**使用`jaeger`需要服务开启请求头转发。
>
> 需要转发的列表：
>
> - x-request-id
> - x-b3-traceid
> - x-b3-spanid
> - x-b3-parentspanid
> - x-b3-sampled
> - x-b3-flags
> - X-ot-span-context



### 2.6 Kiali

&emsp;&emsp;其是专用于`istio`的，它除了提供监控、可视化及跟踪等功能之外。还专门提供了**Istio的配置验证、健康评估等。**

**抛出：**

```shell
kubectl -n istio-system port-forward \
$(kubectl -n istio-system get pod -l app=kiali -o jsonpath='{.items[0].metadata.name}') \ 
9090:9090 &
```







# Istio的HTTP流量管理

此章重点描述的是`Istio`的连接能力【核心能力之一】：

- 如何连接大量的微服务连接在一起，**有效的远程服务调用**。
- 在不可靠的网络环境下，保证微服务**正确的应对网络故障，保证服务质量**。
- **在升级、测试和扩缩容场景，进行有序可靠的流量引导和转移。**
- **在微服务出现故障的时候，能够采取措施进行故障隔离，防止故障扩散影响整体应用的运行**，对业务健壮性是一个重要的保障。



> &emsp;&emsp;而`Istio`能够业务应用无感知的情况下，对应用通信行为进行干涉和保护，将**原本需要在应用中处理的通信功能，下沉到`Istio`进行配置和管理。有效的降低开发和运维成本，提高对服务的控制能力**。





## 一、目标规则

### 1.1 对比原生K8s

- `K8S`：
  - 指定协议、服务名、端口
- `Istio`：
  - 基于`pod`标签的服务进程分组；
  - 自定义的服务负载均衡策略；
  - 可以为服务指定`TLS`要求；
  - 设置服务连接池的大小；

**图片对比：**

![image-20220409203756574](https://gitee.com/tizo_kingbb/picImg/raw/master/img/20220409203756.png)

![image-20220409203816787](https://gitee.com/tizo_kingbb/picImg/raw/master/img/20220409203816.png)

**差异：**

- `Istio`中，客户端只使用一个服务入口就可以访问多个不同的服务，无需客户端干涉。
- `Istio`可以通过流量特征来完成对后端服务的选择。它的流量控制功能会根据每次访问长生的流量进行判断，根据结果去选择一个后段负责本次访问的响应。`K8s`就只有轮询和随机两种不同的负载方式。



### 1.2 Subset子集

&emsp;&emsp;也被称为服务版本，统一服务的不同组别。Istio就是对子集进行选择。

**例子：**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: flaskapp
  labels:
    app: flaskapp
spec:
  selector:
    app: flaskapp
  ports:
    - name: http
      port: 80
---
apiVersion: apps/v1 ### SubSet
kind: Deployment
metadata:
  name: flaskapp-v1
spec:
  replicas: 1
  selector:
    matchLabels:
      app: flaskapp
      version: v1
  template:
    metadata:
      labels:
        app: flaskapp
        version: v1
    spec:
      containers:
      - name: flaskapp
        image: dustise/flaskapp
        imagePullPolicy: Always
        env:
        - name: version
          value: v1
---
apiVersion: apps/v1 ### SubSet
kind: Deployment
metadata:
  name: flaskapp-v2
spec:
  replicas: 1
  selector:
    matchLabels:
      app: flaskapp
      version: v2
  template:
    metadata:
      labels:
        app: flaskapp
        version: v2
    spec:
      containers:
      - name: flaskapp
        image: dustise/flaskapp
        imagePullPolicy: Always
        env:
        - name: version
          value: v2
```



### 1.3 DestinationRule规则

&emsp;&emsp;而`DestinationRule`就定义了去选择`Subset`的规则。

**例子：**

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: flaskapp
spec:
  host: flaskapp.default.svc.cluster.local
  trafficPolicy:
    loadBalancer:
      simple: LEAST_CONN
  subsets:
  - name: v1
    labels:
      version: v1
    trafficPolicy:
      loadBalancer:
        simple: ROUND_ROBIN
  - name: v2
    labels:
      version: v2
```

- `hsot`：一个必要的字段，代表`Kubernetes`中的一个`Service`资源，或者是一个`ServiceEntry`定义的外部服务。为了避免不同命名空间的服务重名建议使用权限定名。也就是使用`FQDN`来进行赋值。
- `trafficPolicy`：是流量策略。Subset的设置级别更高。
- `subsets`：使用标签选择器来定义不同的子集。



### 1.4 VirtualService虚拟服务->路由

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: flaskapp-default-v2
spec:
  hosts:
  - flaskapp.default.svc.cluster.local
  http:
  - route:
    - destination:
        host: flaskapp
        subset: v2
```

- `hosts`：`VirtualService`同样是针对主机名工作的。但很明显这个字段是个数组。他不仅可以针对**多个主机名**进行工作，还可以为**多种协议**的流量提供服务。
- `http`：之下就是路由规则了，支持多条路由。此处定义了一个默认目标。



### 1.5 使用规则进行路由

1. 创建DestinationRule规则

   ```yaml
   apiVersion: networking.istio.io/v1alpha3
   kind: DestinationRule
   metadata:
     name: flaskapp
   spec:
     host: flaskapp.default.svc.cluster.local
     trafficPolicy:
       loadBalancer:
         simple: LEAST_CONN
     subsets:
     - name: v1
       labels:
         version: v1
       trafficPolicy:
         loadBalancer:
           simple: ROUND_ROBIN
     - name: v2
       labels:
         version: v2
   ```

2. 创建路由

   ```yaml
   apiVersion: networking.istio.io/v1alpha3
   kind: VirtualService
   metadata:
     name: flaskapp-default-v2
   spec:
     hosts:
     - flaskapp.default.svc.cluster.local
     http:
     - route:
       - destination:
           host: flaskapp
           subset: v2
   ```

2. 进入程序

   ```shell
   kubectl exec -it -c sleep $(kubectl get pod -l app=sleep,version=v1 -o jsonpath={.items..metadata.name}) bash
   ```

3. 测试

   ```shell
   http --body http://flaskapp/env/version
   v2
   http --body http://flaskapp/env/version
   v2
   http --body http://flaskapp/env/version
   v2
   http --body http://flaskapp/env/version
   v2
   ```

   

## 二、流量的拆分和迁移

1. 在路由配置文件中加入权重后，更新路由

   ```yaml
   apiVersion: networking.istio.io/v1alpha3
   kind: VirtualService
   metadata:
     name: flaskapp-default-v2
   spec:
     hosts:
     - flaskapp.default.svc.cluster.local
     http:
     - route:
       - destination:
           host: flaskapp.default.svc.cluster.local
           subset: v1
         weight: 70
       - destination:
           host: flaskapp.default.svc.cluster.local
           subset: v2
         weight: 30
   ```

2. 统计`v1`被调用的次数

   ```shell
   ### 1、执行10次
   for i in `seq 10`;do http --body http://flaskapp/env/version; done | awk -F"v1" '{print NF-1}'
   ### 2、结果
   7
   
   ### 3、执行100次
   for i in `seq 100`;do http --body http://flaskapp/env/version; done | awk -F"v1" '{print NF-1}'
   ### 4、结果
   71
   ### 5、执行300次
   for i in `seq 300`;do http --body http://flaskapp/env/version; done | awk -F"v1" '{print NF-1}'
   ### 6、结果
   216
   ```

   - 注意：
     - 流量分配是有权重的，**总和必须是100**。
     - 不显示声明权重，则其默认值为100。



### 2.1 如何确认网格现有的路由规则或者其他Istio对象

   1. 使用`kubectl`进行获取
   2. 进入`kiali`的`Istio Config`

   



## 三、金丝雀部署

&emsp;&emsp;就是新的版本只针对一小部分用户开发作为测试。这部分用户对服务的访问会指向特定的版本。此处为例子`V1`为旧版。



1. 更改路由

   ```yaml
   apiVersion: networking.istio.io/v1alpha3
   kind: VirtualService
   metadata:
     name: flaskapp-default-v2
   spec:
     hosts:
     - flaskapp.default.svc.cluster.local
     http:
     - match:
       - headers: ### 不仅仅支持header，还支持uri、scheme、methd、authority、端口、来源标签和gateway等
           lab:
             exact: canary ### exact完全相等，还可以使用 prefix前缀 、 regex正则等匹配方式。
       route:
       - destination:
           host: flaskapp.default.svc.cluster.local
           subset: v2
     - route:
       - destination:
           host: flaskapp.default.svc.cluster.local
           subset: v1
   ```

2. 测试

   ```shell
   ### 1、携带请求头lab:canary
   http --body http://flaskapp/env/version lab:canary
   ### 2、访问到的是v2
   v2
   
   ### 3、去除请求头和携带lab!=canary时
   http --body http://flaskapp/env/version
   http --body http://flaskapp/env/version lab:phoenix
   ### 4、访问到的v1
   v1
   ```



## 四、根据来源进行路由

1. 更改路由

   ```yaml
   apiVersion: networking.istio.io/v1alpha3
   kind: VirtualService
   metadata:
     name: flaskapp-default-v2
   spec:
     hosts:
     - flaskapp.default.svc.cluster.local
     http:
     - match:
       - sourceLabels:
           app: sleep
           version: v1
       route:
       - destination:
           host: flaskapp.default.svc.cluster.local
           subset: v1
     - route:
       - destination:
           host: flaskapp.default.svc.cluster.local
           subset: v2
   ```

2. 测试

   ```shell
   ### sleep1
   http --body http://flaskapp/env/version
   v1
   ### sleep2
   http --body http://flaskapp/env/version
   v2
   ```



## 五、对URI进行重定向

1. 更改路由

   ```yaml
   apiVersion: networking.istio.io/v1alpha3
   kind: VirtualService
   metadata:
     name: flaskapp-default-v2
   spec:
     hosts:
     - flaskapp.default.svc.cluster.local
     http:
     - match:
       - sourceLabels:
           app: sleep
           version: v1
         uri:
           exact: "/env/HOSTNAME"
       redirect:  ### 会把uri整体替换，灵活性不高并且不支持post请求
         uri: /env/version
     - route:
       - destination:
           host: flaskapp.default.svc.cluster.local
           subset: v2
   ```

2. 测试

   ```shell
   ### 1、v2版本发起
   http http://flaskapp/env/HOSTNAME
   HTTP/1.1 200 OK
   content-length: 28
   content-type: text/html; charset=utf-8
   date: Sun, 10 Apr 2022 03:20:33 GMT
   server: envoy
   x-envoy-upstream-service-time: 3
   
   flaskapp-v2-784fb5dcf6-b4qzc
   
   ### 2、v1版本发起
   http --follow http://flaskapp/env/HOSTNAME
   HTTP/1.1 200 OK
   content-length: 2
   content-type: text/html; charset=utf-8
   date: Sun, 10 Apr 2022 03:21:42 GMT
   server: envoy
   x-envoy-upstream-service-time: 3
   
   v2
   ```

   

### 5.1 使用httpbin设置一个使用post方法的重定向

&emsp;&emsp;`httpbin`在`Istio`的`sample`文件夹下，apple就好。

1. 配置路由

   ```yaml
   apiVersion: networking.istio.io/v1alpha3
   kind: VirtualService
   metadata:
     name: httpbin
   spec:
     hosts:
     - httpbin.default.svc.cluster.local
     http:
     - match:
       - uri:
           exact: "/get"
       redirect:
         uri: /post
     - route:
       - destination:
           host: httpbin.default.svc.cluster.local
   ```

2. 测试

   ```shell
   ### 1、正常访问post
   http -f POST http://httpbin:8000/post data=nothing
   HTTP/1.1 200 OK
   access-control-allow-credentials: true
   access-control-allow-origin: *
   content-length: 836
   content-type: application/json
   date: Sun, 10 Apr 2022 03:40:34 GMT
   server: envoy
   x-envoy-upstream-service-time: 35
   
   {
       "args": {},
       "data": "",
       "files": {},
       "form": {
           "data": "nothing"
       },
   
   #### 2、访问get进行重定向
   http --follow -f POST http://httpbin:8000/get data=nothing
   HTTP/1.1 405 Method Not Allowed
   access-control-allow-credentials: true
   access-control-allow-origin: *
   allow: OPTIONS, POST
   content-length: 178
   content-type: text/html
   date: Sun, 10 Apr 2022 03:42:29 GMT
   server: envoy
   x-envoy-upstream-service-time: 41
   
   ```

3. 说明：

   - 根据结果可以看到很明显是没有达到我们的目的的。
   - 解决方案：使用`rewrite`在调用前进行URI重写。

4. 更改路由配置

   ```yaml
   apiVersion: networking.istio.io/v1alpha3
   kind: VirtualService
   metadata:
     name: httpbin
   spec:
     hosts:
     - httpbin.default.svc.cluster.local
     http:
     - match:
       - uri:
           exact: "/get"
       rewrite: ### 使用rewrite，match一节必须包含对目标的定义
         uri: /post
       route:
       - destination:
           host: httpbin.default.svc.cluster.local
     - route:
       - destination:
           host: httpbin.default.svc.cluster.local
   ```

5. 再次测试

   ```shell
   ### 达到预期效果
   http --follow -f POST http://httpbin:8000/get data=nothing
   HTTP/1.1 200 OK
   access-control-allow-credentials: true
   access-control-allow-origin: *
   content-length: 874
   content-type: application/json
   date: Sun, 10 Apr 2022 03:50:22 GMT
   server: envoy
   x-envoy-upstream-service-time: 7
   
   {
       "args": {},
       "data": "",
       "files": {},
       "form": {
           "data": "nothing"
       },
   ```

   



## 六、通讯超时控制

&emsp;&emsp;微服务之间互相调用时发生通讯超时是在所难免的，这种情况要去控制，通常的手段是增加**默认的超时时间**。但是这种情况下，如果故障持续存在就会造成业务积压，一定程度之后可能会导致故障扩散。

&emsp;&emsp;通常情况下我们要针对每个调用点加以控制，这需要不断的进行尝试总结效果，需要投入很多人力和时间才能达到较好的效果。

&emsp;&emsp;`Istio`可以对服务间的超时进行控制，在应用无感知的情况下，根据`VirtualService`的配置，动态调整调用过程中超时上限。从而达到控制事故范围的目的。因为无侵入所以可以节省大量的成本。



1. 配置路由

   ```yaml
   apiVersion: networking.istio.io/v1alpha3
   kind: VirtualService
   metadata:
     name: httpbin
   spec:
     hosts:
     - httpbin.default.svc.cluster.local
     http:
     - timeout: 3s
       route:
         - destination:
             host: httpbin.default.svc.cluster.local
   ```

2. 测试

   ```shell
   ### 测试延迟两秒
   http --body http://httpbin:8000/delay/2
   {
       ....
       "origin": "127.0.0.6",
       "url": "http://httpbin:8000/delay/2"
   }
   
   ### 测试超过两秒的情况
   http --body http://httpbin:8000/delay/3
   upstream request timeout
   http --body http://httpbin:8000/delay/6
   upstream request timeout ### 3秒左右响应
   ```

   

## 七、故障重试控制

&emsp;&emsp;此功能适用于服务发生闪断时，第一次请求不可能而再次请求可能就成功了的情况，。

1. 配置路由

   ```yaml
   apiVersion: networking.istio.io/v1alpha3
   kind: VirtualService
   metadata:
     name: httpbin
   spec:
     hosts:
     - "httpbin.default.svc.cluster.local"
     http:
     - retries:
         attempts: 3 ### 重试3次
         perTryTimeout: 1s
       route:
       - destination:
           host: httpbin.default.svc.cluster.local
   ```

2. 测试

   ```shell
   ### 1、访问接口测试
   http http://httpbin:8000/status/500
   ```

3. 查看`sidecar`日志

   ```shell
   kubectl logs -f httpbin-74fb669cc6-mr8zx -c istio-proxy
   ```

   



## 八、入口流量管理

&emsp;&emsp;`K8s`为第三方厂商提供了`Ingress Controller`规范，用于入站流量管理。`Istio`的早期版本也据此实现了自己的`Ingress Controller`，又因无法满足不断增加的需求，`Istio`推出了`Gateway`的概念。用于网格边缘进行入站和出站的流量管理。

&emsp;&emsp;`Ingress Gateway`在逻辑上相当于网格边缘的一个负载均衡器，用于接受和处理网格边缘出站和入站的网格链接。其中包含开放端口和`TLS`的配置等内容。

&emsp;&emsp;安装`addons`后就已经安装好`gateway`一些细节和其他安装方式详见官网。

> 实际上：
>
> - `VirtualService`对象：都默认包含`gateways`字段。如果没有指定效果如下：
>
>   ```yaml
>   gateways:
>   - mesh
>   ```
>
>   - 这里的`mesh`是`Istio`内部的虚拟`Gateway`,代表网格内部的所有`Sidecar`。
>   - 素有网格内部服务之间的互相通讯都是通过这个`mesh`网关进行的。
>   - 如果想对外提供服务那么就需要定义`Gateway`对象，并给`gateways`字段赋值。



#### 8.1 尝试创建一个gateway

1. 创建gateway

   ```yaml
   apiVersion: networking.istio.io/v1alpha3
   kind: Gateway
   metadata:
     name: example-gateway
   spec:
     selector:
       istio: ingressgateway
     servers:
       - port:
           number: 80
           name: http
           protocol: HTTP
         hosts:
         - "*.microservice.rocks"
         - "*.microservice.xyz"
   ```

2. 尝试访问

   ```shell
   http flaskapp.microservice.rocks
   
   HTTP/1.1 404 Not Found
   content-length: 277
   content-type: text/html; charset=UTF-8
   date: Sun, 10 Apr 2022 07:27:07 GMT
   referrer-policy: no-referrer
   server: envoy
   x-envoy-upstream-service-time: 120
   ### 因为没有指定负责响应的服务，所以404
   ```

3. 针对`flaskapp`的路由进行更改

   ```yaml
   apiVersion: networking.istio.io/v1alpha3
   kind: VirtualService
   metadata:
     name: flaskapp-default-v2
   spec:
     hosts:
     - flaskapp.default.svc.cluster.local
     - flaskapp.microservice.rocks
     gateways:
     - mesh
     - example-gateway
     http:
     - route:
       - destination:
           host: flaskapp.default.svc.cluster.local
           subset: v2
   ```

4. 再次尝试访问

   ```shell
   http flaskapp.microservice.rocks
   
   HTTP/1.1 200 OK
   content-length: 10
   content-type: text/html; charset=utf-8
   date: Sun, 10 Apr 2022 07:33:33 GMT
   server: envoy
   x-envoy-upstream-service-time: 32
   
   I am FINE!
   ```



#### 8.2 为Gateway添加证书支持

&emsp;&emsp;入口网关承担了流量加密的任务，`Ingress Gateway`也具备这样的能力。

1. 使用证书文件创建`Secret`

   ```shell
   kubectl create -n istio-system secret tls \ 
   istio-ingressgateway-certs \
   --key rocks/key.pem --cert rocks/cert.pem 
   ```

2. 修改gateway的定义

   ```yaml
   apiVersion: networking.istio.io/v1alpha3
   kind: Gateway
   metadata:
     name: example-gateway
   spec:
     selector:
       istio: ingressgateway
     servers:
       - port:
           number: 80
           name: http
           protocol: HTTP
         hosts:
         - "*.microservice.rocks"
         - "*.microservice.xyz"
       - port:
           number: 443
           name: https
           protocol: HTTPS
         tls:
           mode: SIMPLE
           serverCertificate: /etc/istio/ingressgateway-certs/tls.crt
           privateKey: /etc/istio/ingressgateway-certs/tls.key
         hosts:
         - "flaskapp.microservice.rocks"
         - "flaskapp.microservice.xyz"
   ```

3. 测试

   ```shell
   http https://flaskapp.microservice.rocks/env/version
   
   v2
   ```



#### 8.3 添加多证书管理

&emsp;&emsp;参照官方文档可见`tls secret`只能包含一个证书对，因此`Gateway`无法处理两个域名的`HTTPS`。**可以换用`Generic`类型的证书**。

```shell
### 删除老的
kubectl delete secret istio-ingressgateway-certs -n istio-system
### 创建新的
kubectl create secret generic \
istio-ingressgateway-certs \
-n istio-system \
--from-file=rocks-cert.pem \
--from-file=rocks-key.pem \
--from-file=xyz-cert.pem \
--from-file=xyz-key.pem 
```

**更新gatewat配置：**

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: example-gateway
spec:
  selector:
    istio: ingressgateway
  servers:
    - port:
        number: 80
        name: http
        protocol: HTTP
      hosts:
      - "*.microservice.rocks"
      - "*.microservice.xyz"
    - port:
        number: 443
        name: https
        protocol: HTTPS
      tls:
        mode: SIMPLE
        serverCertificate: /etc/istio/ingressgateway-certs/rocks-cert.pem
        privateKey: /etc/istio/ingressgateway-certs/rocks-key.pem
      hosts:
      - "flaskapp.microservice.rocks"
    - port:
        number: 443
        name: https
        protocol: HTTPS
      tls:
        mode: SIMPLE
        serverCertificate: /etc/istio/ingressgateway-certs/xyz-cert.pem
        privateKey: /etc/istio/ingressgateway-certs/xyz-key.pem
      hosts:
      - "flaskapp.microservice.xyz"
```



#### 8.4 配置入口流量的路由

&emsp;&emsp;此处配置为外部流量采用v1版本处理。

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: flaskapp-default-v2
spec:
  hosts:
  - flaskapp.default.svc.cluster.local
  - flaskapp.microservice.rocks
  - flaskapp.microservice.xyz
  gateways:
  - mesh
  - example-gateway
  http:
  - match:
    - gateways:
      - example-gateway
    route:
      - destination:
          host: flaskapp.default.svc.cluster.local
          subset: v1
  - route:
    - destination:
        host: flaskapp.default.svc.cluster.local
        subset: v2
```

**测试：**

```shell
http --body http://flaskapp/env/version
v2

http --body http://flaskapp.microservice.rocks/env/version
v1
```



## 九、出口流量管理

&emsp;&emsp;`Istio`在注入后会劫持所有流量，在默认情况下网格内的应用是无法访问网格之外的服务的。



1. 尝试访问`http://api.jd.com`

   ```shell
   http http://api.jd.com
   HTTP/1.1 302 Found
   cache-control: max-age=0
   content-length: 167
   content-type: text/html
   date: Sun, 10 Apr 2022 09:07:49 GMT
   expires: Sun, 10 Apr 2022 09:07:50 GMT
   location: https://developers.jd.com
   server: envoy
   x-envoy-upstream-service-time: 17
   ```

2. 那么如何访问外部呢：

   1. 设置`Sidecar`的流量劫持范围：根据IP地址来告知`Sidecar`，哪些外部资源可以开放访问。
   2. 注册`ServiceEntry`:把网格外部的服务使用`ServiceEntry`的方式注册到网格内部。



### 9.1 设置 Sidecar 的流量劫持范围

**两种方式可以影响它的劫持范围：**

- 第一种：设置`values.yaml`中的`proxy.includeIPRanges`变量。
- 第二种：使用`Pod`注解`traffic.sidecar.istio.io/includeOutboundIPRanges`，表明劫持范围。



1. 重新编辑`sleep-v1`对象

   ```yaml
   ---
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: sleep-v1
     annotations:
       traffic.sidecar.istio.io/includeOutboundIPRanges: 36.110.0.0/16
   spec:
     replicas: 1
     selector:
       matchLabels:
         app: sleep
         version: v1
     template:
       metadata:
         labels:
           app: sleep
           version: v1
       spec:
         containers:
         - name: sleep
           image: dustise/sleep
           imagePullPolicy: Always
   ---
   ```

   

### 9.2 设置 ServiceEntry

&emsp;&emsp;相当于将外部服务在网格内部进行了注册，相当于使用`CIDR`白名单的方式，使得`Istio`对外部服务的访问又了更大的管理能力。

1. 为`httpbin.org`设置一个`ServiceEntry`:

   ```shell
   apiVersion: networking.istio.io/v1alpha3
   kind: ServiceEntry
   metadata:
     name: httpbin-ext
   spec:
     hosts:
     - httpbin.org
     ports:
     - number: 80
       name: http
       protocol: HTTP
     resolution: DNS
   ```

2. 测试

   ```shell
   http http://httpbin.org/get
   HTTP/1.1 200 OK
   access-control-allow-credentials: true
   access-control-allow-origin: *
   content-length: 1347
   content-type: application/json
   date: Sun, 10 Apr 2022 09:26:08 GMT
   server: envoy
   x-envoy-upstream-service-time: 672
   ```

3. 优势

   1. 可以想服务一样配置超时策略等内容。



## 十、设置服务熔断

&emsp;&emsp;熔断是一种保护性措施，常见的降级手段即在服务实例无法正常提供服务的情况下，将其从负载均衡池中移除，不再为其分配任务。等待服务能力恢复后再重新将发生故障的`Pod`加入负载均衡池。

&emsp;&emsp;**`Istio`中同样提供了非入侵式的服务熔断功能：**

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: httpbin
spec:
  host: httpbin
  trafficPolicy:
    connectionPool:
      tcp:
        maxConnections: 1 # 连接池1
      http:
        http1MaxPendingRequests: 1 
        maxRequestsPerConnection: 1 # 连接池1
    outlierDetection:
      consecutive_5xx: 1
      interval: 1s # 每秒做一次请求计数
      baseEjectionTime: 3m # 3分钟后才能再次加入负载均衡池
      maxEjectionPercent: 100
```

**测试：**

```shell
### 添加熔断时
wrk -c 3 -t 3 http://httpbin:8000/ip
Running 10s test @ http://httpbin:8000/ip
  3 threads and 3 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   580.93us    1.07ms  30.06ms   98.24%
    Req/Sec     2.05k   645.70     3.22k    67.11%
  61371 requests in 10.10s, 6.26MB read
  Non-2xx or 3xx responses: 61371
Requests/sec:   6077.38
Transfer/sec:    635.04KB


### 删除熔断后
wrk -c 3 -t 3 http://httpbin:8000/ip
Running 10s test @ http://httpbin:8000/ip
  3 threads and 3 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   539.49us  482.46us  11.20ms   92.04%
    Req/Sec     2.02k   614.97     3.26k    64.67%
  60374 requests in 10.00s, 6.16MB read
  Non-2xx or 3xx responses: 60374
Requests/sec:   6034.92
Transfer/sec:    630.60KB
```







## 十一、故障注入测试

&emsp;&emsp;微服务的测试过程中，往往需要对网络故障的场景进行模拟。`Istio`也在这方面提供了两种故障注入能力：

- 延迟
- 中断



### 1、 延迟注入

**示例`VirtualService`：**

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: httpbin
spec:
  hosts:
  - "httpbin.default.svc.cluster.local"
  http:
  - route:
    - destination:
        host: httpbin.default.svc.cluster.local
    fault:
      delay:
        fixedDelay: 3s
        percent: 100
```

**测试：**

```shell
time http --body http://httpbin:8000/delay/1
。。。
real	0m4.507s
```

> **注意：**
>
> - 注入的延时并不会触发超时。
> - `percent`：是一个百分比，用于指定注入延迟的比率，默认值为：100；
> - `fixedDelay`：表明延迟的时间长度，必须大于1毫秒；



### 2、注入中断

**示例：**

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: httpbin
spec:
  hosts:
  - "httpbin.default.svc.cluster.local"
  http:
  - match:
    - sourceLabels:
        version: v1
    route:
    - destination:
        host: httpbin.default.svc.cluster.local
    fault:
      abort:
        httpStatus: 500
        percentage:
          value: 100
    route:
    - destination:
        host: httpbin.default.svc.cluster.local
```

**测试：**

```shell
### 进入sleep v1
http --body http://httpbin:8000/ip
fault filter abort

### 进入sleep v2
http --body http://httpbin:8000/ip
{
    "origin": "127.0.0.6"
}
```



## 十二、流量复制

&emsp;&emsp;也是一个用于测试的强大功能，其可以把指向一个服务版本的流量复制一份出来，发送给另一个服务版本。**这一功能能够将生产流量导入测试应用，在复制出来的镜像流量发出之后不会等待响应，因此对正常应用的性能影响较小。**

例子：将`flaskapp v1`的流量发送给`v2`

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: flaskapp-default-v2
spec:
  hosts:
  - flaskapp.default.svc.cluster.local
  http:
  - route:
    - destination:
        host: flaskapp.default.svc.cluster.local
        subset: v1
    mirror:
      host: flaskapp.default.svc.cluster.local
      subset: v2
```

**测试：**

```shell
### 1、发送两次请求
http --body http://flaskapp/env/version
v1

http --body http://flaskapp/env/version
v1


### 2、进入两个容器的proxy中查看访问日志

kubectl logs -f $(kubectl get pod -l app=flaskapp,version=v1 -o jsonpath={.items..metadata.name}) -c istio-proxy
kubectl logs -f $(kubectl get pod -l app=flaskapp,version=v2 -o jsonpath={.items..metadata.name}) -c istio-proxy
```



